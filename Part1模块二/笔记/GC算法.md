## GC -- garbish collection

#### 垃圾回收机制

#### 工作内容就是查找垃圾，释放空间，回收空间

- GC算法就是工作时查找垃圾和回收空间 所遵循的规则/计算方式



> ### 引用计数
>
> ### 标记清除
>
> ### 标记整理
>
> ### 分代回收(V8使用)



### 引用计数算法

==核心思想：设置引用计数器，判断当前引用数是否为0==

引用计数器

- 引用关系改变时修改引用数字
- 引用数为0时立即回收

==优点==

- 发现垃圾立即回收(即时回收垃圾对象)
- 开销分布于整个程序运行期间，很平滑，不需要特意挂起程序来做垃圾回收，减少程序暂停。

==缺点==

- 无法回收循环引用的对象(因为引用数不为0)

  ```js
  //举个🌰
  function fn(){
      const ob1 = {};
      const ob2 = {};
      ob1.name = ob2;
      ob2.name = ob1;
  }
  
  fn()
  ```

- 时间开销大(资源消耗大，速度没那么快)





### 标记清除算法

==核心思想：分标记和清除二个阶段完成，遍历所有对象标记活动对象，遍历所以有对象清除无标记对象，回收相应空间==



标记，清除

标记: 找到所有可达对象(会向下递归查找) 找到后标记可达对象

清除: 找到没有标记的对象 也清除掉之前做的标记



==优点==

可处理对象循环引用问题，可以回收循环引用的对象

==缺点==

容易产生碎片化空间，浪费空间

不会立即回收垃圾对象(要等到遍历完的最后才进行清除)



### 标记整理算法

==核心思想：标记清除的增强，标记阶段和标记清除算法相同，清除阶段先执行整理移动对象位置，再执行清除操作==

**`整理地址空间`**

==优点==

减少碎片化空间

==缺点==

无法立即回收垃圾对象