# 吴智翀 | 模块一

## 简答题

> 此处回答简答题的内容。每一题为一个三级标题，可以后面跟上题目，也可以不跟，下面为格式示例：

### 第一题:请说出下列最终的执行结果，并解释为什么？

```js
var a = [];
for (var i = 0; i < 10; i++){
    a[i] = function() {
        console.log(i)
    }
}
a[6]();
```

最终执行结果为: 打印出 10

原因: var声明的i成为全局变量了，每次循环创建代码块和进行赋值时使用的都是同一个全局变量i，所以循环结束后，这个全局变量i已经变成了10，此时调用方法打印i就得到了10。



### 第二题:请说出下列最终的执行结果，并解释为什么？

```js
var tmp = 123;
if(true) {
    console.log(tmp);
    let tmp;
}
```

最终执行结果: 会报错，tmp未定义

原因: 因为let的暂时性死区，在代码块内 如果有let声明，它所声明的变量就绑定在该区域不受外部影响，而在let声明之前 都是无法使用变量的，在代码块开始 直到变量声明之间 的 区域即为暂时性死区，暂时性死区内用了变量就会报错。



### 第三题:结合ES6新语法，用自简单的方式找出数组中的最小值。

```js
var arr = [12,34,32,89,4]
```

解答:

```js
const min = Math.min(...arr);
console.log(min);
```

min即最小值



### 第四题:请详细说明var,let,const 三种声明变量方式之间的具体区别。

解答:

- var: 可以跨块级作用域访问，同一作用域下可重复声明，若在全局作用域下声明，相当于给全局对象添加一个属性，存在变量提升不存在暂时性死区。
- let: 不可以跨块级作用域访问, 同一作用域下不可重复声明，存在暂时性死区。
- const: 不可以跨块级作用域访问, 同一作用域下不可重复声明，存在暂时性死区，声明时必须初始化赋值。

let和var声明的变量可以修改，原始数据类型可以修改值，复杂数据类型可以修改地址或属性值

const声明的变量不可以修改，原始数据类型不可以修改值，复杂数据类型不可以修改地址但可以修改属性值(实际地址不变)



### 第五题:请说出下列代码最终输出结果，并解释为什么?

```js
var a = 10;
var obj = {
    a: 20,
    fn() {
        setTimeout(()=>{
            console.log(this.a)
        })
    }
}
obj.fn();
```

最终执行结果: 20

原因: 由于此处setTimeout使用的是箭头函数，所以this指向相当于setTimeout外层的this指向，即相当于 fn(){console.log(this.a)}

而由于是obj对象来调用fn 所以this指向obj，则this.a为20

若将setTimeout中的箭头函数改为function，则this即指向了全局对象，会输出10



### 第六题:简述Symbol类型的用途

解答:

- 可以生成一个唯一的标记
- 可作为对象的唯一键
- 为数据结构实现Symbol.iterator可让该数据结构可迭代
- 使用Symbol可以为class或对象 创建私有属性或隐藏属性



### 第七题:说说什么是浅拷贝、什么是深拷贝？

解答:

- 深拷贝:指开辟新的内存空间，将一个对象的属性完全复制到新对象上，修改一个对象的属性不会影响另一个对象的属性。

- 浅拷贝:指将一个对象的内存地址复制给新对象；还有一种情况，若新对象只有部分属性是开辟了新的内存空间复制了原对象属性，而部分属性只是复制了内存地址，也是浅拷贝。

  即修改新对象的某属性还是可能会影响到原对象属性。



### 第八题:谈谈你是如何理解JS异步编程的，Event Loop是做什么的，什么是宏任务，什么是微任务？

解答:

JS本身是单线程运行的同步模式，为了解决耗时任务阻塞当前进程的问题，引入了异步模式。

JS异步编程 由 事件循环、消息队列、宏任务微任务、Promise方案、generator方案等实现。



- Event Loop: 相当于一个工具，进行 等待任务，从消息队列中拿出任务执行，等待任务 这样的一个无限循环。
- 宏任务: 回调队列中的任务，会在回调队列中排队一个个执行，大部分的异步调用API都作为宏任务进入回调队列。
- 微任务: 在一个宏任务末尾处顺带执行的工作，在当前任务结束后立即执行，会在下一个宏任务之前全部执行完毕。Promise、node中的process.nextTick、mutationObserver、queueMicroTask()都属于微任务。



### 第九题:将下面异步代码使用Promise改进

```js
setTimeout(function() {
    var a = 'hello';
    setTimeout(function () {
        var b = 'lagou';
        setTimeout(function () {
            var c = 'I❤️U';
            console.log(a+b+c);
        },10)
    },10)
},10)
```



解答:

```js
var a = 'hello',
    b = 'lagou',
    c = 'I❤️U';

const promisify = (param,func,time) =>
	new Promise(resolve => {
		func(()=>resolve(param),time)
	})

promisify(a,setTimeout,10)
	.then(res=>promisify(res+b,setTimeout,10))
	.then(res=>promisify(res+c,setTimeout,10))
	.then(res=>console.log(res))
```



### 第十题:请简述TypeScript与JavaScript之间的关系?

解答:

TS是JS的扩展集，扩充了更强大更安全的类型系统以及对ES6+新特性的更好支持。

TS可被编译后成为JS代码，用JS编写的合法代码在TS中也有效。

TS在开发时就能够提示编译错误，JS则要在运行时才会暴露错误。

TS是强类型、静态类型语言，而JS是弱类型、动态类型语言。





### 第十一题:请谈谈你所认为的TypeScript优缺点?

解答:

优点:

拥有强大的类型系统，让代码可阅读性和可维护性提高，项目的多人协作更加安全和友好。

掌握JS的开发者可以渐进式地使用和学习TS，过渡平滑，比较友好。

拥有活跃的社区，稳定的官方(微软大哥)支持，原生态IDE支持。

对ES6+新特性更快更好的支持。

相比JS增加了更多特性，可以提供更强大的功能。



缺点

相比JS增加了一些新概念例如接口、泛型、枚举等，学习成本提高。

项目初期，TS会增加开发成本，因为需要单独维护类型声明。

集成和构建流程相比JS更加复杂，需要更多工作量。

部分第三方库可能对ts的支持不如js好。



